## 1장 다중 통화를 지원하는 Money 객체: TDD 방법
### TDD 방법
1. 필요한 Use Case를 나열한다. -> 테스트해야 하는 유스 케이스 문서(체크리스트)를 작성한다.
2. 테스트 코드를 작성한다
3. 테스트 코드가 실패하도록 한다. -> 테스트의 컴파일 오류를 제거한다.
4. 테스트 코드가 성공하도록 한다.
5. 소스 코드의 중복을 제거한다. -> 소스 코드를 리팩토링한다.
6. 이를 모든 유스 케이스의 시나리오가 완성될 때까지 반복한다.
7. 만약 작성 도중 새로운 시나리오가 등장하면, 유스 케이스 문서에 추가해둔다.

> TDD의 핵심은 문제를 잘게 쪼개는 능력이다.
> 한꺼번에 일을 진행하지 않고, 조금씩 단계를 쪼개는 능력으로 막히는 문제를 구체화하며 해결해야 한다.

> 작동하는 코드를 먼저 만들고, 깔끔한 코드를 그 다음으로 만들자.

## 2장 - 타락한 객체: 좋은 테스트 코드

### 테스트 코드를 성공하도록 만드는 방법
1. 가짜로 구현하기: 상수를 반환하게 만들고, 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
2. 명백한 구현 사용하기: 일반화된 실제 구현을 입력한다.

> 중요한 것은, 보폭의 조절이다.
> 성큼 걸을 수 있다면 성큼 걷고, 성큼 걸어지지 않는다면 종종걸음으로 걸어라.
 
### 좋은 테스트 코드
- 설계상의 결함을 잡을 수 있는 테스트 코드를 작성하자. 사이드 이펙트가 보이도록 테스트 코드를 작성해라.
- 코드의 "미적 판단"을 테스트에 담아낼 수 있도록 테스트 코드를 작성하자.
- 설계가 올바르게 되어있는지 검토하기 위한 테스트 코드를 작성하자.


## 3장 - 모두를 위한 평등: Value Object 테스트
### 삼각 측량
- 성공 테스트 케이스와 실패 테스트 케이스를 모두 작성하라.
- 테스트 케이스는 2개 이상의 일반화 검증을 수행하라.
- 테스트 케이스는 2개 이상의 경계값 검증을 수행하라.

## 4장 - 프라이버시: private 접근 제어자 붙이기
> 한 테스트 코드에는 되도록이면 한가지만 테스트할 수 있도록 설계해라.


## 5장 - 솔직히 말하자면
> 엄격한 규칙에 얽메이지 말고, 일단 쪼개라.

> 중복을 제거하기 전에는 집에 가지 않겠다고 약속해라.


## 6장 - 돌아온 모두를 위한 평등: Equals 메소드를 Money 클래스로 옮기기
코틀린의 Data class를 사용하고 있으므로 스킵함.

## 7장 - 사과와 오렌지 - Franc와 Dollar 비교하기
클래스 타입 불일치를 테스트 코드로 검증했다.

## 8장 - 객체 만들기: Dollar/Franc 중복
> 하위 클래스가 그다지 않은 일을 하고 있지 않다면, 하위 클래스를 제거하는건 어떨지 생각해봐라.
- 하위 클래스에 대한 직접적인 참조(하위 클래스만의 메소드/필드 참조)가 제거된다면, 하위 클래스를 제거하기 위해 한발짝 다가갔다고 할 수 있다.
> 테스트 코드의 생성 기준은 새로운 구현의 발생이 아닌 새로운 시나리오의 발생이다.


## 9장 - 우리가 사는 시간: 통화 개념 도입
> 하던 일을 중단하고 전혀 다른 일을 하는 상태에서, 그 일을 또 중단하지는 말자.
> 작업의 깊이가 지나치게 깊어지지 않도록 조심하자.

> 언제나 개발과 유지보수를 위한 "최선의 보폭"이 제일 중요하다.
> TDD도 결국은 생산성을 위한 도구이다.
> 정해진 올바른 보폭이라는 건 존재하지 않는다.


## 10장 - 흥미로운 시간: 공용 times
> 때로는 이전에 했던 실수를 인정하고 되돌리는 과감함이 필요하다.

### 반드시 테스트 코드를 작성하고 구현해야 하는 엄격한 규칙처럼 받아들이지 마라.
- toString() 메소드를 테스트 코드를 작성하지 않고 구현했다.
  - 화면에 나타나는 결과를 보기 위해 만들었다.
  - 디버그 출력용으로만 쓰니, 잘못 구현되도 큰 문제가 없다.
  - 이미 빨간 막대 상태에서 새로운 테스트를 작성하지는 않는게 좋아보인다.

## 11장 - 모든 악의 근원: 중목 제거
> 중복은 제거하라. 소스 코드에서도, 테스트 코드에서도

> 필요없는 테스트는 제거하라.
> 불필요한 요구사항이 여전히 남아있는 것처럼 보일 수 있다.


## 12장 - 드디어, 더하기: 같은 타입 덧셈 구현
- 문제를 쪼개라.
  - 바로 어려운것부터 하지 말고, 쉬운 문제부터 차근차근 수행하라.
  - 체계적인 상태를 유지해라.

> 테스트 코드는 기교에 대한 통찰을 보장해주진 않지만, 기교를 적용할 준비를 돕는다.

> 한번에 계산하기 어렵다면, 중간 상태를 생성해봐라.

> 테스트를 구현하고 나면, 해당 테스트만을 만족시키는 스텁을 먼저 구현하라.


## 13장 - 진짜로 만들기: stub 제거
컴포지트 패턴이라면 때로는 기본 동작을 정의하는게 유용할수도 있다.

개념적 일관성과 컴포지트 패턴 갖추기

> 모든 중복이 제거되기 전까지는 테스트 코드를 통과한 것으로 치지 마라.


## 14장 - 바꾸기: 환전 기능 추가
- 문제가 진척이 되지 않으면, 병목의 원인을 찾고, 별도의 테스트를 추가하라.


## 15장 - 서로 다른 통화 더하기
- Expression.plus() 메소드가 추가되어야 하는 이유가 뭐지?
- `val result = bank.reduce(fiveDollar.plus(tenFranc).plus(sevenDollar), "USD")`